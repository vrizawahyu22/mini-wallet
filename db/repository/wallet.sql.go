// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: wallet.sql

package querier

import (
	"context"
)

const checkWalletExists = `-- name: CheckWalletExists :one
SELECT EXISTS (
  SELECT id FROM "wallet" WHERE user_id=$1
)
`

func (q *Queries) CheckWalletExists(ctx context.Context, userID string) (bool, error) {
	row := q.db.QueryRow(ctx, checkWalletExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO "transaction"(id, user_id, status, type, balance, reference_id)
VALUES($1, $2, $3, $4, $5, $6) RETURNING id, user_id, status, type, balance, reference_id, transaction_at, created_at, updated_at
`

type CreateTransactionParams struct {
	ID          string  `json:"id"`
	UserID      string  `json:"user_id"`
	Status      string  `json:"status"`
	Type        string  `json:"type"`
	Balance     float64 `json:"balance"`
	ReferenceID string  `json:"reference_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.Type,
		arg.Balance,
		arg.ReferenceID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Type,
		&i.Balance,
		&i.ReferenceID,
		&i.TransactionAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO "wallet"(id, user_id, status, balance)
VALUES($1, $2, $3, $4) RETURNING id, user_id, status, balance, enabled_at, created_at, updated_at
`

type CreateWalletParams struct {
	ID      string  `json:"id"`
	UserID  string  `json:"user_id"`
	Status  string  `json:"status"`
	Balance float64 `json:"balance"`
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.Balance,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Balance,
		&i.EnabledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findTokenByUserId = `-- name: FindTokenByUserId :one
SELECT id, token, created_at, updated_at FROM "users" WHERE token=$1
`

func (q *Queries) FindTokenByUserId(ctx context.Context, token string) (User, error) {
	row := q.db.QueryRow(ctx, findTokenByUserId, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findTransactionByUserId = `-- name: FindTransactionByUserId :many
SELECT id, user_id, status, type, balance, reference_id, transaction_at, created_at, updated_at FROM "transaction" WHERE user_id=$1 ORDER BY created_at ASC
`

func (q *Queries) FindTransactionByUserId(ctx context.Context, userID string) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, findTransactionByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.Type,
			&i.Balance,
			&i.ReferenceID,
			&i.TransactionAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUser = `-- name: FindUser :one
SELECT id, token, created_at, updated_at FROM "users" WHERE id=$1
`

func (q *Queries) FindUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, findUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findWalletByUserId = `-- name: FindWalletByUserId :one
SELECT id, user_id, status, balance, enabled_at, created_at, updated_at FROM "wallet" WHERE user_id=$1
`

func (q *Queries) FindWalletByUserId(ctx context.Context, userID string) (Wallet, error) {
	row := q.db.QueryRow(ctx, findWalletByUserId, userID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Balance,
		&i.EnabledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatBalanceWalletByUserId = `-- name: UpdatBalanceWalletByUserId :one
UPDATE "wallet" 
SET 
  balance=$1
WHERE user_id=$2 RETURNING id, user_id, status, balance, enabled_at, created_at, updated_at
`

type UpdatBalanceWalletByUserIdParams struct {
	Balance float64 `json:"balance"`
	UserID  string  `json:"user_id"`
}

func (q *Queries) UpdatBalanceWalletByUserId(ctx context.Context, arg UpdatBalanceWalletByUserIdParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updatBalanceWalletByUserId, arg.Balance, arg.UserID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Balance,
		&i.EnabledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWalletByUserId = `-- name: UpdateWalletByUserId :one
UPDATE "wallet" 
SET 
  status=$1,
  enabled_at=NOW()
WHERE user_id=$2 RETURNING id, user_id, status, balance, enabled_at, created_at, updated_at
`

type UpdateWalletByUserIdParams struct {
	Status string `json:"status"`
	UserID string `json:"user_id"`
}

func (q *Queries) UpdateWalletByUserId(ctx context.Context, arg UpdateWalletByUserIdParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWalletByUserId, arg.Status, arg.UserID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Balance,
		&i.EnabledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
